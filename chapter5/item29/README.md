`제네릭 (5장)`

# [ITEM29] 이왕이면 제네릭 타입으로 만들라

## 1. 실체화 불가 타입으로는 배열을 만들 수 없다
> 아이템 28에서 설명한 것처럼, E와 같은 실체화 불가 타입으로는 배열을 만들 수 없다. 배열을 사용하 코드를 제네릭으로 만들려 할 때는 이 문제가 항상 발목을 잡을 것이다.
___
` 이유 `

* *(내가 생각한 이유) : 배열은 공변 타입이라 런타임에 실체화된다. 근데 실체화 불가 타입은 컴파일 시점에만 타입 정보를 갖고 있고, 런타임에는 타입 정보를 갖고 있지 않는다.*

* 배열은 공변하며 런타임에 실체화 되지만, 제네릭 타입은 불공변하며 런타임에 소거된다. 이로 인해 배열은 **타입 안전성을 보장해줄 수 없어** 제네릭 배열을 직접 생성할 수 없습니다.

` 해결방법`

#### 와일드카드 타입을 이용한 제네릭 배열 생성
```java
// 컴파일 에러가 발생 안함.
List<?>[] lists = new List<?>[2];
lists[0] = Arrays.asList(1);
lists[1] = Arrays.asList("A");
    for (List<?> list : lists) {
        System.out.println(list);
    }
}
```
* 비한정적 와일드카드 타입으로 제네릭 배열을 생성하면 컴파일에러가 발생하지 않는다.
* 비한정적 와일드카드 타입은 모든 제네릭 타입을 가질 수 있다. 
* 그러므로 raw 타입으로 정의한 List[]와 동일한 의미를 가지므로 컴파일 에러를 발생시키지 않는다.
  * raw 타입이기 때문에 모든 타입을 포함할 수 있어 배열의 공변성이 문제가 되지 않음.
###
#### 형변한 이용하기
```java
public class Store<E> {
    private E[] elements;
    private int index;
    
    // 경고가 발생하나 타입 안전성을 확신할 수 있으니 경고를 제거한다.
    @SuppressWarnings("unchecked")
    public Store(int size) {
     // this.elements = new E[size]; 직접 제네릭 배열은 생성불가!
        this.elements = (E[]) new Object[size]; // 강제 형변환을 이용하여 생성
        this.index = 0;
    }
    
    // elements는 해당 메서드에서만 추가될 수 있으므로 코드상으로 타입 안전성 보장이 가능하다. 
    public boolean save(E e) {
        if (index >= elements.length)
            return false;
        
        elements[index++] = e;
        return true;
    }
}
```


###2. 이해 안되는 문구
> 174p. 사실 제네릭 타입 안에서 리스트를 사용하는 게 항상 가능하지도, 꼭 더 좋은 것도 아니다. 자바가 리스트를 기본 타입으로 제공하지 않으므로 ArrayList 같은 제네릭 타입도 결국은 기본 타입인 배열을 사용해 구현해야 한다. 또한 HashMap 같은 제네릭 타입은 성능을 높일 목적으로 배열을 사용하기도 한다.
___

`내용 정리`
> 클라이언트에서 직접 형변환 해야 하는 타입보다, 제네릭 타입이 더 안전하고 쓰기 편하다. 그러니 새로운 타입을 설계할 때는 형변환 없이도 사용할 수 있도록 하자.(= 제네릭 타입)



